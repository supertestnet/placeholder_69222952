<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <title>Aggeus Market</title>
        <!--
        <script src="https://supertestnet.github.io/bankify/super_nostr.js"></script>
        <script src="https://unpkg.com/@cmdcode/tapscript@1.4.0"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        -->
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/super_nostr.js"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/tapscript@1.5.3"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/noble-secp256k1@1.2.14"></script>
        <script>
            var mempool_client = async ( network, command, params ) => {
                if ( typeof network === "object" ) {
                    var [ miner, relay ] = network;
                    var commander = async ( command, params ) => {
                        var privkey = super_nostr.getPrivkey();
                        var pubkey = super_nostr.getPubkey( privkey );
                        var msg = JSON.stringify({msg_type: command, msg_value: params});
                        var emsg = await super_nostr.alt_encrypt( privkey, miner, msg );
                        var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", miner ] ] );
                        super_nostr.sendEvent( event, relay );
                        var loop = async () => {
                            await super_nostr.waitSomeSeconds( 1 );
                            var ids = null;
                            var authors = [ miner ];
                            var kinds = [ 4 ];
                            var until = null;
                            var since = null;
                            var limit = 1;
                            var etags = null;
                            var ptags = [ pubkey ];
                            var events = await super_nostr.getEvents( relay, ids, authors, kinds, until, since, limit, etags, ptags );
                            if ( !events.length ) return loop();
                            var event = events[ 0 ];
                            var recipient = event.pubkey;
                            var content = await super_nostr.alt_decrypt( privkey, recipient, event.content );
                            var json = JSON.parse( content );
                            return json.msg_value;
                        }
                        var reply = await loop();
                        return reply;
                    }
                }
                var reply = await commander( command, params );
                return reply;
            }
        </script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 800px;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
                padding: 0;
            }
            body {
                margin: 3rem 1rem;
                word-wrap: break-word;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            .hidden {
                display: none !important;
            }
            .bold {
                font-weight: bold;
            }
            .market {
                border: 1px solid black;
                border-radius: 1rem;
                padding: 1rem;
                margin: .5rem;
                text-align: center;
                float: left;
                width: 100%;
                max-width: 10rem;
            }
            .yes_or_no_box {
                border: 1px solid black;
                border-radius: 1rem;
                padding: 1rem;
                margin: .5rem;
                text-align: center;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
            var hash_arr = window.location.href.substring( window.location.href.indexOf( "#" ) ).split( "#" );
            hash_arr.splice( 0, 1 );
            var $_HASH = {}
            hash_arr.forEach( item => {
                var vals = item.split( "=" );
                $_HASH[ vals[ 0 ] ] = vals[ 1 ];
            });
        </script>
    </head>
    <body>
        <div class="top_level_page home_page">
            <h1>Welcome to Aggeus</h1>
            <div class="markets_on_display"></div>
        </div>
        <div class="top_level_page loading_page hidden">
            <p>loading...</p>
        </div>
        <div class="top_level_page market_page hidden">
            <h1 class="market_name">Market page</h1>
            <div class="yes_or_no_box yes_box">
                <p class="bold">Bet on Yes</p>
                <div class="yes_qr_code"></div>
                <p>Current chance: <span class="current_chance">60%</span></p>
                <p class="yes_up_or_down">Up</p>
                <p><button class="users_yes_info_btn">Your "Yes" info</button></p>
                <div class="users_yes_info hidden">
                    <p>Your deposits so far: <span class="yes_balance">0</span> sats</p>
                    <p>Amount lost to mining fees: <span class="lost_to_fees">0</span> sats</p>
                    <p>How many sats you can withdraw (i.e. amount not in active contracts): <span class="withdrawable_balance">0</span> sats</p>
                    <p>Amount of sats in active contracts (and thus not withdrawable): <span class="unwithdrawable_balance">0</span> sats</p>
                    <p>Balance you might get on resolution day if all your contracts get purchased and your side wins: <span class="expected_balance">0</span> sats</p>
                    <p>Amount you might earn right now if you list your position for sale and someone buys it: <span class="earnings_possible_now">0</span> sats</p>
                </div>
            </div>
            <div class="yes_or_no_box no_box">
                <p class="bold">Bet on No</p>
                <div class="no_qr_code"></div>
                <p>Current chance: <span class="current_chance">40%</span></p>
                <p class="no_up_or_down">Down</p>
                <p><button class="users_no_info_btn">Your "No" info</button></p>
                <div class="users_no_info hidden">
                    <p>Your deposits so far: <span class="no_balance">0</span> sats</p>
                    <p>Amount lost to mining fees: <span class="lost_to_fees">0</span> sats</p>
                    <p>How many sats you can withdraw (i.e. amount not in active contracts): <span class="withdrawable_balance">0</span> sats</p>
                    <p>Amount of sats in active contracts (and thus not withdrawable): <span class="unwithdrawable_balance">0</span> sats</p>
                    <p>Balance you might get on resolution day if all your contracts get purchased and your side wins: <span class="expected_balance">0</span> sats</p>
                    <p>Amount you might earn right now if you list your position for sale and someone buys it: <span class="earnings_possible_now">0</span> sats</p>
                </div>
            </div>
        </div>
        <script>
            var aggeus_interface = {
                mempool_network: "testnet",
                nums_point: "a".repeat( 64 ),
                coordinators_privkey: "3bda6a1ea0c75a2d07a6475e8e91f08d3e551f629c17213dd732fb96c53b41a5",
                coordinators_pubkey: super_nostr.getPubkey( "3bda6a1ea0c75a2d07a6475e8e91f08d3e551f629c17213dd732fb96c53b41a5" ),
                // coordinators_relays: [ "wss://no.str.cr" ],
                coordinators_relays: [ "ws://127.0.0.1:6969/" ],
                hexToBytes: hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) ),
                getAddressData: ( scripts, index ) => {
                    var tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var [ tpubkey, cblock ] = tapscript.Tap.getPubKey( aggeus_interface.nums_point, { tree, target: tree[ index ] });
                    var address = tapscript.Address.p2tr.fromPubKey( tpubkey, aggeus_interface.mempool_network );
                    return [ address, tree, cblock ];
                },
            }
            var privkey = super_nostr.getPrivkey();
            if ( $_HASH.network ) var network = $_HASH.network;
            else var network = null;
            var markets = [
                "WzAsIldpbGwgdGhlIFJlcHVibGljYW4gYmVhdCB0aGUgRGVtb2NyYXQ/IiwiMzk4ZjBiM2E5NWM1YTNkOTUyMTgyZDZkNDBjYjRmYzNmMWIyMGZhYzRhYjE4N2UzNDg3M2RjYTVmYzNhYzFjMyIsImRhOGU2MTc2YzI0MTg1NGUzNmIzYzIzYzA5YWY0OGQyMmJjNjI4MjFiZTk3MWM1YTI5YjA0NzIwN2QzOTI5YmYiLCIyZjRkYTVkMWM1ZmJhNTJhOWM2OWRjNmUzZjE2NGFmOThiOWVjYTk5MDA0NzQ4NjRmMjk5MmRmNWJhYzc1ZTEzIiwxMCwiYjE3YmUwZjU2NmYxODQ3ZWUyOGM4OWZhM2VhNjhiNDI1ZGUyODM2ODc1MDc3NDAzZWRjOTE0NmMyYzkzMzU1YiIsIjI3YTE2ZWI4OTY2Y2MwYjJlNWU0ODZlYzQ1ZTZjY2ZlMzRkMGNiMGNiMzA0YWVlZDU5MTAyNDhmYWJlM2Q3MjciLFsid3NzOi8vbm9zdHIuYml0Y29pbmVyLnNvY2lhbCJdXQ==",
                "WzAsIldpbGwgYmlwNDQ0IGFjdGl2YXRlPyIsIjNlODU0ZTFmMWQ1OWM3M2UzMGM5ZDFmZTdmNDI2MDBlODY1Zjc1NjI5Y2I1MjIxOGIxZWQxODQ3NDU0N2YwZDAiLCJlNmNjN2RkZDQzMzZmZDQzMjkyNjNjMTA0NzYxNDg0YmI3NWMxMjQ3NDkyZGE2M2Y0MzI5YjMxMmEwY2ViNmIzIiwiMmY0ZGE1ZDFjNWZiYTUyYTljNjlkYzZlM2YxNjRhZjk4YjllY2E5OTAwNDc0ODY0ZjI5OTJkZjViYWM3NWUxMyIsMTAsIjE2MmE3ZGU5MTEzOTczYzU2ZTIxNTZhNDQ3M2E3YjMzMjZmODNiZDU4ODZhOGJhYWVhZGFlOTA2MmZlNDY1MmQiLCIxY2JhN2UwMWRjZjU3MmFjNjFjZjg5ZmNhY2QxNThjNDc1MTBmNzI5NjQ3M2JkMWRiODY0OTkwODk1OGM3OTUyIixbIndzczovL25vc3RyLmJpdGNvaW5lci5zb2NpYWwiXV0="
            ];
            var offers = {};
            var betters = {};
            var displayMarket = async shareable_data => {
                var market_data = JSON.parse( atob( shareable_data ) );
                var market_id = market_data[ 2 ];

                //Get all matching offers from the coordinator
                showPage( 'loading_page' );
                var c_talker = async ( miner, relay, command, params ) => {
                    var privkey = super_nostr.getPrivkey();
                    var pubkey = super_nostr.getPubkey( privkey );
                    var msg = JSON.stringify({msg_type: command, msg_value: params});
                    var emsg = await super_nostr.alt_encrypt( privkey, miner, msg );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", miner ] ] );
                    super_nostr.sendEvent( event, relay );
                    var num_of_loops = 0;
                    var loop = async () => {
                        num_of_loops = num_of_loops + 1;
                        if ( num_of_loops > 3 ) return 'no_coordinator';
                        await super_nostr.waitSomeSeconds( 1 );
                        var ids = null;
                        var authors = [ miner ];
                        var kinds = [ 4 ];
                        var until = null;
                        var since = null;
                        var limit = 1;
                        var etags = null;
                        var ptags = [ pubkey ];
                        var events = await super_nostr.getEvents( relay, ids, authors, kinds, until, since, limit, etags, ptags );
                        if ( !events.length ) return loop();
                        var event = events[ 0 ];
                        var recipient = event.pubkey;
                        var content = await super_nostr.alt_decrypt( privkey, recipient, event.content );
                        var json = JSON.parse( content );
                        return json.msg_value;
                    }
                    var reply = await loop();
                    return reply;
                }
                var reply = await c_talker( aggeus_interface.coordinators_pubkey, aggeus_interface.coordinators_relays[ 0 ], "ping" );
                if ( reply === "no_coordinator" ) return alert( `this market has no coordinator, try again` );

                var yes_privkey = await super_nostr.sha256( `y${privkey}${market_id}0` );
                var no_privkey = await super_nostr.sha256( `n${privkey}${market_id}0` );
                var yes_pubkey = super_nostr.getPubkey( yes_privkey );
                var no_pubkey = super_nostr.getPubkey( no_privkey );
                var yes_address = tapscript.Address.fromScriptPubKey( [ 1, yes_pubkey ], aggeus_interface.mempool_network );
                var no_address = tapscript.Address.fromScriptPubKey( [ 1, no_pubkey ], aggeus_interface.mempool_network );
                $( '.yes_qr_code' ).innerText = yes_address;
                $( '.no_qr_code' ).innerText = no_address;
                showPage( 'market_page' );
                var listenForCoins = async network => {
                    console.log( `waiting for user's deposit...` );
                    await super_nostr.waitSomeSeconds( 1 );
                    if ( !network ) network = prompt( "enter network, either in the form pubkey,wss://relay.example.com or a url such as https://mempool.guide/api" );
                    if ( network.includes( "," ) ) network = network.split( "," );
                    var yes_utxos = await mempool_client( network, "utxos", yes_address );
                    var no_utxos = await mempool_client( network, "utxos", no_address );
                    if ( !yes_utxos.length && !no_utxos.length ) return listenForCoins( network );
                    return { yes_utxos, no_utxos }
                }
                var utxos = await listenForCoins( network );
                console.log( 'utxos:' );
                console.log( utxos );
                var yes_balance = 0;
                utxos.yes_utxos.forEach( utxo => {
                    yes_balance = yes_balance + utxo.value;
                });
                var no_balance = 0;
                utxos.no_utxos.forEach( utxo => {
                    no_balance = no_balance + utxo.value;
                });

                //Check if any offers match what the user is looking for. For example, if the user deposited into Yes when the odds are currently 60/40, they should expect to pay 6000 sats, and seek offers where they pay 6200 sats or less, i.e. offers with odds of 62/38, 61/39, 60/40, etc. And if the user deposited into No in such a case, they should expect to pay 4200 sats, and seek offers where the yes_better offers odds of 58/42, 59/41, 60/40, etc.
                var matching_offers = {buying_yes: [], buying_no: []};
                var remaining_yes_balance = yes_balance;
                var remaining_no_balance = no_balance;
                if ( yes_balance ) {
                    var all_offers = await c_talker( aggeus_interface.coordinators_pubkey, aggeus_interface.coordinators_relays[ 0 ], "get_offers", { market_id, type: "for_sale_by_no_better", max_price: ( 60 * 100 ) + ( 2 * 100 ) });
                    all_offers.forEach( offer => {
                        if ( offer[ 1 ] > remaining_yes_balance ) return;
                        matching_offers[ "buying_yes" ].push( offer );
                        remaining_yes_balance = remaining_yes_balance - offer[ 1 ];
                    });
                }
                if ( no_balance ) {
                    var all_offers = await c_talker( aggeus_interface.coordinators_pubkey, aggeus_interface.coordinators_relays[ 0 ], "get_offers", { market_id, type: "for_sale_by_yes_better", max_price: ( 40 * 100 ) + ( 2 * 100 ) } );
                    all_offers.forEach( offer => {
                        if ( offer[ 1 ] > remaining_no_balance ) return;
                        matching_offers[ "buying_no" ].push( offer );
                        remaining_no_balance = remaining_no_balance - offer[ 1 ];
                    });
                }

                //Create a PSBT to buy the matching offers -- note that the new user was told what outputs the original depositor wanted so that he (the new user) can create his psbt in such a way that his input(s) get(s) consumed in a single transaction that simultaneously funds all the offers desired by the original depositor -- and if he has any change, this tx simultaneously creates outputs controlled by the new user, but which the proxy is authorized to convert into contracts later -- but I forgot to do this in such a way that the user is sure to get the 10k sat outputs *he* wants
                var match_vin = [];
                var match_vout = [];
                matching_offers.buying_yes.forEach( offer => {
                    var tx = tapscript.Tx.decode( offer[ 2 ] );
                    var new_vin = tx.vin[ 0 ];
                    new_vin.prevout = {
                        value: 10_000 - ( ( 60 * 100 ) - ( 2 * 100 ) ),
                        scriptPubKey: [ 1, "a".repeat( 64 ) ],
                    }
                    match_vin.push( new_vin );
                    match_vout.push( tx.vout[ 0 ] );
                });
                matching_offers.buying_no.forEach( offer => {
                    var tx = tapscript.Tx.decode( offer[ 2 ] );
                    var new_vin = tx.vin[ 0 ];
                    new_vin.prevout = {
                        value: 10_000 - ( ( 40 * 100 ) - ( 2 * 100 ) ),
                        scriptPubKey: [ 1, "a".repeat( 64 ) ],
                    }
                    match_vin.push( new_vin );
                    match_vout.push( tx.vout[ 0 ] );
                });
                utxos.yes_utxos.forEach( utxo => {
                    match_vin.push({
                        txid: utxo.txid,
                        vout: utxo.vout,
                        witness: [],
                        prevout: {
                            value: utxo.value,
                            scriptPubKey: tapscript.Address.toScriptPubKey( yes_address ),
                        },
                    });
                });
                utxos.no_utxos.forEach( utxo => {
                    match_vin.push({
                        txid: utxo.txid,
                        vout: utxo.vout,
                        witness: [],
                        prevout: {
                            value: utxo.value,
                            scriptPubKey: tapscript.Address.toScriptPubKey( no_address ),
                        },
                    });
                });

                //Divide up the remaining Yes balance into utxos each worth 10k sats - ( current_percentage * 100 )
                var yes_inputs = [];
                var yes_outputs = [];
                utxos.yes_utxos.forEach( utxo => {
                    yes_inputs.push({
                        txid: utxo.txid,
                        vout: utxo.vout,
                        witness: [],
                        prevout: {
                            value: utxo.value,
                            scriptPubKey: tapscript.Address.toScriptPubKey( yes_address ),
                        },
                    });
                });
                var num_of_yes_outputs_to_make = Math.floor( remaining_yes_balance / ( 10_000 - ( ( 40 * 100 ) - ( 2 * 100 ) ) ) );
                var yes_change = remaining_yes_balance % ( 10_000 - ( ( 40 * 100 ) - ( 2 * 100 ) ) );
                var i; for ( i=0; i<num_of_yes_outputs_to_make; i++ ) {
                    if ( matching_offers.buying_yes.length ) {
                        match_vout.push({
                            value: ( 10_000 - ( ( 40 * 100 ) - ( 2 * 100 ) ) ),
                            scriptPubKey: tapscript.Address.toScriptPubKey( yes_address ),
                        });
                    } else {
                        yes_outputs.push({
                            value: ( 10_000 - ( ( 40 * 100 ) - ( 2 * 100 ) ) ),
                            scriptPubKey: tapscript.Address.toScriptPubKey( yes_address ),
                        });
                    }
                }
                if ( yes_change >= 330 ) {
                    if ( matching_offers.buying_yes.length ) {
                        match_vout.push({
                            value: yes_change,
                            scriptPubKey: tapscript.Address.toScriptPubKey( yes_address ),
                        });
                    } else {
                        yes_outputs.push({
                            value: yes_change,
                            scriptPubKey: tapscript.Address.toScriptPubKey( yes_address ),
                        });
                    }
                }
                var yes_psbt = {
                    vin: yes_inputs,
                    vout: yes_outputs,
                }
                var i; for ( i=0; i<yes_psbt.vin.length; i++ ) {
                    var sig = "0".repeat( 128 );
                    yes_psbt.vin[ i ].witness = [ sig ];
                }
                if ( matching_offers.buying_yes.length ) {
                    yes_psbt = {
                        vin: match_vin,
                        vout: match_vout,
                    }
                    var i; for ( i=matching_offers.buying_yes.length; i<yes_psbt.vin.length; i++ ) {
                        var sig = "0".repeat( 128 );
                        yes_psbt.vin[ i ].witness = [ sig ];
                    }
                }

                //Do the same thing for No that you just did for Yes
                var no_inputs = [];
                var no_outputs = [];
                utxos.no_utxos.forEach( utxo => {
                    no_inputs.push({
                        txid: utxo.txid,
                        vout: utxo.vout,
                        witness: [],
                        prevout: {
                            value: utxo.value,
                            scriptPubKey: tapscript.Address.toScriptPubKey( no_address ),
                        },
                    });
                });
                var num_of_no_outputs_to_make = Math.floor( remaining_no_balance / ( 10_000 - ( ( 60 * 100 ) - ( 2 * 100 ) ) ) );
                var no_change = remaining_no_balance % ( 10_000 - ( ( 60 * 100 ) - ( 2 * 100 ) ) );
                var i; for ( i=0; i<num_of_no_outputs_to_make; i++ ) {
                    if ( matching_offers.buying_no.length ) {
                        match_vout.push({
                            value: ( 10_000 - ( ( 60 * 100 ) - ( 2 * 100 ) ) ),
                            scriptPubKey: tapscript.Address.toScriptPubKey( no_address ),
                        });
                    } else {
                        no_outputs.push({
                            value: ( 10_000 - ( ( 60 * 100 ) - ( 2 * 100 ) ) ),
                            scriptPubKey: tapscript.Address.toScriptPubKey( no_address ),
                        });
                    }
                }
                if ( no_change >= 330 ) {
                    if ( matching_offers.buying_no.length ) {
                        match_vout.push({
                            value: no_change,
                            scriptPubKey: tapscript.Address.toScriptPubKey( no_address ),
                        });
                    } else {
                        no_outputs.push({
                            value: no_change,
                            scriptPubKey: tapscript.Address.toScriptPubKey( no_address ),
                        });
                    }
                }
                var no_psbt = {
                    vin: no_inputs,
                    vout: no_outputs,
                }
                var i; for ( i=0; i<no_psbt.vin.length; i++ ) {
                    var sig = "0".repeat( 128 );
                    no_psbt.vin[ i ].witness = [ sig ];
                }
                if ( matching_offers.buying_no.length ) {
                    no_psbt = {
                        vin: match_vin,
                        vout: match_vout,
                    }
                    var i; for ( i=matching_offers.buying_no.length; i<no_psbt.vin.length; i++ ) {
                        var sig = "0".repeat( 128 );
                        no_psbt.vin[ i ].witness = [ sig ];
                    }
                }
                var subtractFeesFromOutputs = ( psbt, feerate ) => {
                    if ( !psbt.vout.length ) return 'error';
                    var size_of_psbt = tapscript.Tx.util.getTxSize( tapscript.Tx.create( psbt ) ).vsize;
                    var fee_needed = feerate * size_of_psbt;
                    var sum_of_inputs = 0;
                    var sum_of_outputs = 0;
                    psbt.vin.forEach( input => sum_of_inputs = sum_of_inputs + Number( input.prevout.value ) );
                    psbt.vout.forEach( output => sum_of_outputs = sum_of_outputs + Number( output.value ) );
                    var fee_so_far = sum_of_inputs - sum_of_outputs;
                    if ( fee_so_far >= fee_needed && fee_so_far - fee_needed >= 330 ) {
                        console.log( 'fee so far:', fee_so_far );
                        console.log( 'fee_needed:', fee_needed );
                        console.log( 'sats you will lose if you proceed:', fee_so_far - fee_needed );
                        return 'error';
                    }
                    else if ( fee_so_far >= fee_needed ) return psbt;
                    var remaining_fee_needed = fee_needed - fee_so_far;
                    psbt.vout.forEach( ( vout, index ) => psbt.vout[ index ].value = Number( vout.value ) );
                    var temp_psbt = JSON.parse( JSON.stringify( psbt ) );
                    if ( temp_psbt.vout[ temp_psbt.vout.length - 1 ].value > remaining_fee_needed + 330 ) {
                        temp_psbt.vout[ temp_psbt.vout.length - 1 ].value = temp_psbt.vout[ temp_psbt.vout.length - 1 ].value - remaining_fee_needed;
                        return temp_psbt;
                    } else {
                        temp_psbt.vout.splice( temp_psbt.vout.length - 1, 1 );
                        return subtractFeesFromOutputs( temp_psbt, feerate );
                    }
                }
                var num_of_vouts_in_original_psbt = yes_psbt.vout.length + no_psbt.vout.length;
                //TODO: get feerate from the blockchain
                var feerate = 1;
                var yes_psbt_minus_fees = yes_psbt;
                if ( yes_psbt.vin.length && !matching_offers.buying_yes.length ) yes_psbt_minus_fees = subtractFeesFromOutputs( yes_psbt, feerate );
                var no_psbt_minus_fees = no_psbt;
                if ( no_psbt.vin.length && !matching_offers.buying_no.length ) no_psbt_minus_fees = subtractFeesFromOutputs( no_psbt, feerate );
                var num_of_vouts_in_psbt_now = yes_psbt_minus_fees.vout.length + no_psbt_minus_fees.vout.length;
                var change_address_exists = yes_change >= 330 || no_change >= 330;
                if ( num_of_vouts_in_psbt_now !== num_of_vouts_in_original_psbt ) var change_address_exists = false;

                //Define the smart contract between the coordinator and the new user, if needed
                //Note that this smart contract used to be encoded as this address: tb1pr60dhp5hwpyeas00zfsczpgnmsddn49fj3wnlnzug37sk2w0r0kq5w7847
                if ( !matching_offers.buying_yes.length && !matching_offers.buying_no.length ) var vins_to_skip = 0;
                else vins_to_skip = matching_offers.buying_yes.length + matching_offers.buying_no.length;
                var coordinator_to_user_contracts = [];
                var i; for ( i=0; i<vins_to_skip; i++ ) {
                    if ( !yes_psbt_minus_fees.vout.length ) continue;
                    var yes_scripts = [
                        [ aggeus_interface.coordinators_pubkey, "OP_CHECKSIGVERIFY", yes_pubkey, "OP_CHECKSIG" ],
                        [ "OP_RETURN", i ],
                    ];
                    var [ yes_contract ] = aggeus_interface.getAddressData( yes_scripts, 0 );
                    coordinator_to_user_contracts.push( [ yes_contract, yes_scripts, "user_bets_yes", ( 60 * 100 ) - ( 2 * 100 ) ] );
                }
                var i; for ( i=0; i<vins_to_skip; i++ ) {
                    if ( !no_psbt_minus_fees.vout.length ) continue;
                    var no_scripts = [
                        [ aggeus_interface.coordinators_pubkey, "OP_CHECKSIGVERIFY", no_pubkey, "OP_CHECKSIG" ],
                        [ "OP_RETURN", i ],
                    ];
                    var [ no_contract ] = aggeus_interface.getAddressData( no_scripts, 0 );
                    coordinator_to_user_contracts.push( [ no_contract, no_scripts, "user_bets_no", ( 40 * 100 ) - ( 2 * 100 ) ] );
                }

                //Define the number of outputs controlled by the user; this variable will be used later, but it seems wise to define it here, before more outputs get added which the coordinator must fund, otherwise it's harder to calculate later
                var num_of_user_controlled_outputs_except_change = yes_psbt_minus_fees.vout.length + no_psbt_minus_fees.vout.length - vins_to_skip;
                if ( change_address_exists ) num_of_user_controlled_outputs_except_change = num_of_user_controlled_outputs_except_change - 1;
                console.log( 'num_of_user_controlled_outputs_except_change:', num_of_user_controlled_outputs_except_change, yes_psbt_minus_fees, vins_to_skip );

                //if necessary, add 10k sat outputs that fund the above-mentioned smart contracts between the coordinator and the new user, and which the coordinator must supply inputs for
                if ( vins_to_skip ) {
                    var i; for ( i=0; i<vins_to_skip; i++ ) {
                        if ( !yes_psbt_minus_fees.vout.length ) continue;
                        yes_psbt_minus_fees.vout.push({
                            value: 10_000,
                            scriptPubKey: tapscript.Address.toScriptPubKey( coordinator_to_user_contracts[ i ][ 0 ] ),
                        });
                    }
                    var i; for ( i=0; i<vins_to_skip; i++ ) {
                        if ( !no_psbt_minus_fees.vout.length ) continue;
                        no_psbt_minus_fees.vout.push({
                            value: 10_000,
                            scriptPubKey: tapscript.Address.toScriptPubKey( coordinator_to_user_contracts[ i ][ 0 ] ),
                        });
                    }
                    var offer_id = super_nostr.getPrivkey().substring( 0, 16 );
                }

                //sign the modified transactions
                var i; for ( i=vins_to_skip; i<yes_psbt_minus_fees.vin.length; i++ ) {
                    var sig = tapscript.Signer.taproot.sign( yes_privkey, yes_psbt_minus_fees, i ).hex;
                    if ( vins_to_skip ) var sig = tapscript.Signer.taproot.sign( yes_privkey, yes_psbt_minus_fees, i, {sigflag: 1 | 128} ).hex;
                    yes_psbt_minus_fees.vin[ i ].witness = [ sig ];
                }
                var i; for ( i=vins_to_skip; i<no_psbt_minus_fees.vin.length; i++ ) {
                    var sig = tapscript.Signer.taproot.sign( no_privkey, no_psbt_minus_fees, i ).hex;
                    //TODO: add a 10k sat output for each of these that funds a smart contract between the coordinator and the new user, and which the coordinator must supply inputs for
                    if ( vins_to_skip ) var sig = tapscript.Signer.taproot.sign( no_privkey, no_psbt_minus_fees, i, {sigflag: 1 | 128} ).hex;
                    no_psbt_minus_fees.vin[ i ].witness = [ sig ];
                }

                //Define the smart contracts by which the user enters into a Yes or No position
                //Note that the Yes position used to be encoded as this address: tb1pgkykn7dqs4umtr3ggej3dekz2fa7ecjm8tzcns3fq6y508uf7dvsvhnswg
                //And the No position used to be encoded as this address: tb1ppywlyhjxh35jxt3u47jdhj4gm55ewq654qr5qj8wtjfzjx9cjd0qurfgum
                var num_of_yes_outputs_to_turn_info_offers = yes_psbt_minus_fees.vout.length;
                var num_of_no_outputs_to_turn_info_offers = no_psbt_minus_fees.vout.length;
                var yes_contracts = [];
                var no_contracts = [];
                var i; for ( i=0; i<num_of_user_controlled_outputs_except_change; i++ ) {
                    if ( !yes_psbt_minus_fees.vout.length ) continue;
                    var yes_scripts = [
                        [ yes_pubkey, "OP_CHECKSIGVERIFY", aggeus_interface.coordinators_pubkey, "OP_CHECKSIG" ],
                        [ "OP_RETURN", i ],
                    ];
                    var [ yes_contract ] = aggeus_interface.getAddressData( yes_scripts, 0 );
                    yes_contracts.push( [ yes_contract, yes_scripts, "user_bets_yes", ( 10_000 - ( ( 60 * 100 ) - ( 2 * 100 ) ) ) ] );
                }
                var i; for ( i=0; i<num_of_user_controlled_outputs_except_change; i++ ) {
                    if ( !no_psbt_minus_fees.vout.length ) continue;
                    var no_scripts = [
                        [ no_pubkey, "OP_CHECKSIGVERIFY", aggeus_interface.coordinators_pubkey, "OP_CHECKSIG" ],
                        [ "OP_RETURN", i ],
                    ];
                    var [ no_contract ] = aggeus_interface.getAddressData( no_scripts, 0 );
                    no_contracts.push( [ no_contract, no_scripts, "user_bets_no", ( 10_000 - ( ( 40 * 100 ) - ( 2 * 100 ) ) ) ] );
                }

                //For each of the user's outputs created by the above psbts, sign a tx that lets the coordinator turn them into offers
                var yes_psbt_txid = tapscript.Tx.util.getTxid( yes_psbt_minus_fees );
                var new_yes_psbts = [];
                var i; for ( i=vins_to_skip; i<vins_to_skip + num_of_user_controlled_outputs_except_change; i++ ) {
                    if ( !yes_psbt_minus_fees.vout.length ) continue;
                    var vout = yes_psbt_minus_fees.vout[ i ];
                    vout.value = Number( vout.value );
                    if ( vout.value !== ( 10_000 - ( ( 40 * 100 ) - ( 2 * 100 ) ) ) ) continue;
                    var new_psbt = {
                        vin: [{
                            txid: yes_psbt_txid,
                            vout: i,
                            witness: [],
                            prevout: vout,
                        }],
                        vout: [{
                            value: 10_000,
                            scriptPubKey: tapscript.Address.toScriptPubKey( yes_contracts[ i - vins_to_skip ][ 0 ] ),
                        }],
                    }
                    new_yes_psbts.push( new_psbt );
                }
                var no_psbt_txid = tapscript.Tx.util.getTxid( no_psbt_minus_fees );
                var new_no_psbts = [];
                var i; for ( i=vins_to_skip; i<vins_to_skip + num_of_user_controlled_outputs_except_change; i++ ) {
                    if ( !no_psbt_minus_fees.vout.length ) continue;
                    var vout = no_psbt_minus_fees.vout[ i ];
                    vout.value = Number( vout.value );
                    if ( vout.value !== ( 10_000 - ( ( 60 * 100 ) - ( 2 * 100 ) ) ) ) continue;
                    var new_psbt = {
                        vin: [{
                            txid: no_psbt_txid,
                            vout: i,
                            witness: [],
                            prevout: vout,
                        }],
                        vout: [{
                            value: 10_000,
                            scriptPubKey: tapscript.Address.toScriptPubKey( no_contracts[ i - vins_to_skip ][ 0 ] ),
                        }],
                    }
                    new_no_psbts.push( new_psbt );
                }

                //Sign the new psbts with sighash_single | anyone_can_pay i.e. 3 | 128
                var i; for ( i=0; i<new_yes_psbts.length; i++ ) {
                    var sig = tapscript.Signer.taproot.sign( yes_privkey, new_yes_psbts[ i ], 0, {sigflag: 3 | 128} ).hex;
                    new_yes_psbts[ i ].vin[ 0 ].witness = [ sig ];
                }
                var i; for ( i=0; i<new_no_psbts.length; i++ ) {
                    var sig = tapscript.Signer.taproot.sign( no_privkey, new_no_psbts[ i ], 0, {sigflag: 3 | 128} ).hex;
                    new_no_psbts[ i ].vin[ 0 ].witness = [ sig ];
                }

                //Tell the coordinator about the matching offers and give him your psbt
                if ( yes_psbt_minus_fees.vout.length ) var tx_to_work_with = yes_psbt_minus_fees;
                else var tx_to_work_with = no_psbt_minus_fees;
                tx_to_work_with.vin.forEach( ( vin, index ) => tx_to_work_with.vin[ index ].prevout.value = Number( vin.prevout.value ) );
                tx_to_work_with.vout.forEach( ( vout, index ) => tx_to_work_with.vout[ index ].value = Number( vout.value ) );
                var offer_ids = [];
                matching_offers.buying_yes.forEach( ( yes_offer, index ) => {
                    offer_ids.push( yes_offer[ 0 ].split( "_" )[ 0 ] );
                });
                matching_offers.buying_no.forEach( ( no_offer, index ) => {
                    offer_ids.push( no_offer[ 0 ].split( "_" )[ 0 ] );
                });
                if ( vins_to_skip ) var funding_txid = await c_talker( aggeus_interface.coordinators_pubkey, aggeus_interface.coordinators_relays[ 0 ], "accept_offers", { market_id, offer_ids, psbt: tx_to_work_with });

                //Tell the user what is happening now
                if ( vins_to_skip ) {
                    console.log( 'the coordinator broadcasted this tx:' );
                    console.log( funding_txid );
                    console.log( 'now I will share my other offers, if any, with the coordinator' );
                } else {
                    console.log( 'now I am broadcasting the funding tx:' );
                    console.log( tapscript.Tx.encode( tx_to_work_with ).hex );
                    var txid = await mempool_client( network.split( "," ), "broadcast", tapscript.Tx.encode( tx_to_work_with ).hex );
                    console.log( 'success!' );
                    console.log( txid );
                    console.log( 'now I will share my offers with the coordinator' );
                }
                var offers_already_sent = [];
                matching_offers.buying_yes.forEach( ( yes_offer, index ) => {
                    var offer_id = yes_offer[ 0 ].split( "_" )[ 0 ];
                    var funding_vout = tx_to_work_with.vout.length - ( index + 1 );
                    offers[ `${offer_id}_${market_id}` ] = { offer_id, market_id, yes_psbt: null, no_psbt: null, odds_per_yes_better: null, odds_per_no_better: null, yes_better: yes_address, no_better: null, odds_when_yes_better_entered: [ 60 - 2, 40 + 2 ], odds_when_no_better_entered: null, status: "active", funding_outpoint: `${funding_txid}_${funding_vout}` };
                    offers_already_sent.push( `${offer_id}_${market_id}` );
                });
                matching_offers.buying_no.forEach( ( no_offer, index ) => {
                    var offer_id = no_offer[ 0 ].split( "_" )[ 0 ];
                    var funding_vout = tx_to_work_with.vout.length - ( index + 1 );
                    offers[ `${offer_id}_${market_id}` ] = { offer_id, market_id, yes_psbt: null, no_psbt: null, odds_per_yes_better: null, odds_per_no_better: null, yes_better: null, no_better: no_address, odds_when_yes_better_entered: null, odds_when_no_better_entered: [ 60 + 2, 40 - 2 ], status: "active", funding_outpoint: `${funding_txid}_${funding_vout}` };
                    offers_already_sent.push( `${offer_id}_${market_id}` );
                });
                if ( new_yes_psbts.length ) new_yes_psbts.forEach( psbt => {
                    psbt = tapscript.Tx.encode( tapscript.Tx.create( psbt ) ).hex;
                    var offer_id = super_nostr.getPrivkey().substring( 0, 16 );
                    offers[ `${offer_id}_${market_id}` ] = { offer_id, market_id, yes_psbt: psbt, no_psbt: null, odds_per_yes_better: [ 60 + 2, 40 - 2 ], odds_per_no_better: null, yes_better: yes_address, no_better: null, odds_when_yes_better_entered: [ 60 + 2, 40 - 2 ], odds_when_no_better_entered: null, status: "pending", funding_outpoint: null };
                });
                if ( new_no_psbts.length ) new_no_psbts.forEach( psbt => {
                    psbt = tapscript.Tx.encode( tapscript.Tx.create( psbt ) ).hex;
                    var offer_id = super_nostr.getPrivkey().substring( 0, 16 );
                    offers[ `${offer_id}_${market_id}` ] = { offer_id, market_id, yes_psbt: null, no_psbt: psbt, odds_per_yes_better: null, odds_per_no_better: [ 60 - 2, 40 + 2 ], yes_better: null, no_better: no_address, odds_when_yes_better_entered: null, odds_when_no_better_entered: [ 60 - 2, 40 + 2 ], status: "pending", funding_outpoint: null };
                });
                var offers_to_send = {}
                Object.keys( offers ).forEach( offer_id => {
                    if ( offers_already_sent.includes( offer_id ) ) return;
                    offers_to_send[ offer_id ] = offers[ offer_id ];
                })
                c_talker( aggeus_interface.coordinators_pubkey, aggeus_interface.coordinators_relays[ 0 ], "create_offers", offers_to_send );
                var sum_of_inputs = 0;
                var sum_of_outputs = 0;
                tx_to_work_with.vin.forEach( vin => sum_of_inputs = sum_of_inputs + Number( vin.prevout.value ) );
                tx_to_work_with.vout.forEach( vout => sum_of_outputs = sum_of_outputs + Number( vout.value ) );
                var lost_to_fees = sum_of_inputs - sum_of_outputs;
                if ( lost_to_fees < 0 ) lost_to_fees = 0;
                $( '.yes_balance' ).innerText = yes_balance;
                $( '.no_balance' ).innerText = no_balance;
                $$( '.lost_to_fees' ).forEach( item => item.innerText = lost_to_fees );
                $$( '.withdrawable_balance' ).forEach( item => item.innerText = yes_balance + no_balance - lost_to_fees );
                console.log( `now I am waiting for money to enter these addresses:` );
                var yes_addresses = [];
                yes_contracts.forEach( ct => yes_addresses.push( [ ct[ 0 ], ct[ 3 ] ] ) );
                var no_addresses = [];
                no_contracts.forEach( ct => no_addresses.push( [ ct[ 0 ], ct[ 3 ] ] ) );
                var coordinator_to_user_addresses = [];
                coordinator_to_user_contracts.forEach( ct => coordinator_to_user_addresses.push( [ ct[ 0 ], ct[ 3 ] ] ) );
                console.log( [ ...yes_addresses, ...no_addresses, ...coordinator_to_user_addresses ] );
                $$( '.expected_balance' ).forEach( item => item.innerText = [ ...yes_addresses, ...no_addresses, ...coordinator_to_user_addresses ].length * 10_000 );
                var listenForCoins = async ( network, addresses = [] ) => {
                    console.log( `waiting for money to enter smart contracts...` );
                    await super_nostr.waitSomeSeconds( 1 );
                    if ( !network ) network = prompt( "enter network, either in the form pubkey,wss://relay.example.com or a url such as https://mempool.guide/api" );
                    if ( network.includes( "," ) ) network = network.split( "," );
                    var results = {}
                    var recheck = true;
                    var i; for ( i=0; i<addresses.length; i++ ) {
                        var address = addresses[ i ][ 0 ];
                        var utxos = await mempool_client( network, "utxos", address );
                        if ( utxos.length ) results[ address ] = addresses[ i ][ 1 ];
                        if ( utxos.length && recheck && i ) {
                            recheck = false;
                            i=-1;
                        }
                    }
                    if ( !Object.keys( results ).length ) return listenForCoins( network, addresses );
                    return results;
                }
                var results = await listenForCoins( network, [ ...yes_addresses, ...no_addresses, ...coordinator_to_user_addresses ] );
                var sum_of_immovable_funds = 0;
                var active_contracts = [];
                Object.keys( results ).forEach( result => {
                    sum_of_immovable_funds = sum_of_immovable_funds + results[ result ];
                    active_contracts.push( result );
                });
                console.log( 'active_contracts:', active_contracts );
                $$( '.unwithdrawable_balance' ).forEach( item => item.innerText = sum_of_immovable_funds );
                $$( '.withdrawable_balance' ).forEach( item => item.innerText = Number( item.innerText ) -sum_of_immovable_funds );
            }
            var displayMarkets = async markets => {
                markets.forEach( shareable_data => {
                    var market_data = JSON.parse( atob( shareable_data ) );
                    var div = document.createElement( "div" );
                    div.className = "market";
                    div.setAttribute( "data-shareable_data", shareable_data );
                    div.innerHTML = `
                        <div class="market_title"></div>
                        <div class="market_btn"><p><button class="visit_market_btn">Visit market</button></p></div>
                    `;
                    div.getElementsByClassName( "market_title" )[ 0 ].innerText = market_data[ 1 ];
                    div.getElementsByClassName( "visit_market_btn" )[ 0 ].onclick = () => {displayMarket( shareable_data )};
                    $( '.markets_on_display' ).append( div );
                });
            }
            if ( !$_HASH.network ) {
                var network = prompt( "enter network, either in the form pubkey,wss://relay.example.com or a url such as https://mempool.guide/api" );
                var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + `#network=${network}`;
                window.location.href = url;
                window.location.reload();
            }
            displayMarkets( markets );
            if ( $_HASH.run_coordinator ) {
                (async()=>{
                    console.log( 'i am the coordinator!' );
                    var listenFunction = async socket => {
                        var subId = super_nostr.bytesToHex( crypto.getRandomValues( new Uint8Array( 8 ) ) );
                        var filter  = {}
                        filter.kinds = [ 4 ];
                        filter[ "#p" ] = [ aggeus_interface.coordinators_pubkey ];
                        filter.since = Math.floor( Date.now() / 1000 );
                        var subscription = [ "REQ", subId, filter ];
                        socket.send( JSON.stringify( subscription ) );
                    }
                    var handleFunction = async message => {
                        var [ type, subId, event ] = JSON.parse( message.data );
                        if ( !event || event === true ) return;
                        var relay = aggeus_interface.coordinators_relays[ 0 ];
                        var recipient = event.pubkey;
                        var content = await super_nostr.alt_decrypt( aggeus_interface.coordinators_privkey, recipient, event.content );
                        var json = JSON.parse( content );
                        console.log( content );
                        if ( json.msg_type === "ping" ) {
                            var message = JSON.stringify({
                                msg_type: "ping_reply",
                                msg_value: "pong",
                            });
                            var emsg = await super_nostr.alt_encrypt( aggeus_interface.coordinators_privkey, recipient, message );
                            var event = await super_nostr.prepEvent( aggeus_interface.coordinators_privkey, emsg, 4, [ [ "p", recipient ] ] );
                            super_nostr.sendEvent( event, relay );
                        }
                        if ( json.msg_type === "get_offers" ) {
                            var market_id = json.msg_value.market_id;
                            var relevant_offers = [];
                            Object.keys( offers ).forEach( offer_id => {
                                if ( !offer_id.endsWith( market_id ) ) return;
                                var offer = offers[ offer_id ];
                                if ( json.msg_value.type === "for_sale_by_no_better" && !offer.odds_per_no_better ) return;
                                if ( json.msg_value.type === "for_sale_by_yes_better" && !offer.odds_per_yes_better ) return;
                                if ( json.msg_value.type === "for_sale_by_no_better" ) {
                                    var price = offer.odds_per_no_better[ 0 ] * 100;
                                    var psbt = offer.no_psbt;
                                }
                                if ( json.msg_value.type === "for_sale_by_yes_better" ) {
                                    var price = offer.odds_per_yes_better[ 1 ] * 100;
                                    var psbt = offer.yes_psbt;
                                }
                                if ( price > json.msg_value.max_price ) return;
                                relevant_offers.push( [ offer_id, price, psbt ] );
                            });
                            var message = JSON.stringify({
                                msg_type: "get_offers_reply",
                                msg_value: relevant_offers,
                            });
                            var emsg = await super_nostr.alt_encrypt( aggeus_interface.coordinators_privkey, recipient, message );
                            var event = await super_nostr.prepEvent( aggeus_interface.coordinators_privkey, emsg, 4, [ [ "p", recipient ] ] );
                            super_nostr.sendEvent( event, relay );
                        }
                        if ( json.msg_type === "create_offers" ) {
                            //TODO: validate the user submitted data before entering it into your db
                            var user_submitted_offers = json.msg_value;
                            Object.keys( user_submitted_offers ).forEach( offer_id => {
                                if ( offers.hasOwnProperty( offer_id ) ) return;
                                offers[ offer_id ] = user_submitted_offers[ offer_id ];
                                var market_id = user_submitted_offers[ offer_id ].market_id;
                                var yes_better = user_submitted_offers[ offer_id ].yes_better;
                                var no_better = user_submitted_offers[ offer_id ].no_better;
                                if ( yes_better && !betters.hasOwnProperty( yes_better ) ) betters[ yes_better ] = [];
                                if ( no_better && !betters.hasOwnProperty( no_better ) ) betters[ no_better ] = [];
                                if ( yes_better ) betters[ yes_better ].push( `${offer_id}_${market_id}` );
                                if ( no_better ) betters[ no_better ].push( `${offer_id}_${market_id}` );
                            });
                            var message = JSON.stringify({
                                msg_type: "create_offers_reply",
                                msg_value: "success",
                            });
                            var emsg = await super_nostr.alt_encrypt( aggeus_interface.coordinators_privkey, recipient, message );
                            var event = await super_nostr.prepEvent( aggeus_interface.coordinators_privkey, emsg, 4, [ [ "p", recipient ] ] );
                            super_nostr.sendEvent( event, relay );
                        }
                        if ( json.msg_type === "accept_offers" ) {
                            //TODO: instead of taking a psbt from the user, have him tell you his inputs and the offers he is accepting, and then *recreate* the psbt
                            var market_id = json.msg_value.market_id;
                            var tx_to_work_with = json.msg_value.psbt;
                            var offers_accepted = json.msg_value.offer_ids;
                            //If the user found matching offers, act as the coordinator to add an input to his tx that funds his contracts and pays the requisite fees
                            var sum_of_inputs = 0;
                            tx_to_work_with.vin.forEach( input => sum_of_inputs = sum_of_inputs + Number( input.prevout.value ) );
                            var sum_of_outputs = 0;
                            tx_to_work_with.vout.forEach( output => sum_of_outputs = sum_of_outputs + Number( output.value ) );
                            var difference = sum_of_outputs - sum_of_inputs;
                            //create a fake input in that tx so you can calculate its size after accounting for the utxo you are about to add to it
                            tx_to_work_with.vin.push({
                                txid: "a".repeat( 64 ),
                                vout: 0,
                                witness: [ "a".repeat( 128 ) ],
                            });
                            //TODO: get feerate from the blockchain
                            var feerate = 1;
                            var size_of_psbt = tapscript.Tx.util.getTxSize( tapscript.Tx.create( tx_to_work_with ) ).vsize;
                            var fee_needed = feerate * size_of_psbt;
                            var total_needed = difference + fee_needed;
                            var fee_privkey = super_nostr.getPrivkey();
                            var fee_pubkey = super_nostr.getPubkey( fee_privkey );
                            var fee_address = tapscript.Address.fromScriptPubKey( [ 1, fee_pubkey ], aggeus_interface.mempool_network );
                            console.log( `send ${total_needed} sats to this address:` );
                            console.log( fee_address );
                            alert( `send ${total_needed} sats to the address in your console, then click ok` );
                            var listenForCoins = async ( network, address ) => {
                                console.log( `waiting for coordinator's deposit...` );
                                await super_nostr.waitSomeSeconds( 1 );
                                if ( !network ) network = prompt( "enter network, either in the form pubkey,wss://relay.example.com or a url such as https://mempool.guide/api" );
                                if ( network.includes( "," ) ) network = network.split( "," );
                                var utxos = await mempool_client( network, "utxos", address );
                                if ( !utxos.length ) return listenForCoins( network, address );
                                return utxos;
                            }
                            var utxos = await listenForCoins( network, fee_address );
                            var fee_txid = utxos[ 0 ].txid;
                            var fee_vout = utxos[ 0 ].vout;
                            var fee_amnt = utxos[ 0 ].value;
                            tx_to_work_with.vin.pop();
                            tx_to_work_with.vin.push({
                                txid: fee_txid,
                                vout: fee_vout,
                                prevout: {
                                    value: fee_amnt,
                                    scriptPubKey: tapscript.Address.toScriptPubKey( fee_address ),
                                },
                            });
                            var sig = tapscript.Signer.taproot.sign( fee_privkey, tx_to_work_with, tx_to_work_with.vin.length - 1 ).hex;
                            tx_to_work_with.vin[ tx_to_work_with.vin.length - 1 ].witness = [ sig ];
                            console.log( 'now broadcasting this psbt:' );
                            console.log( tapscript.Tx.encode( tx_to_work_with ).hex );
                            var txid = await mempool_client( network.split( "," ), "broadcast", tapscript.Tx.encode( tx_to_work_with ).hex );
                            var message = JSON.stringify({
                                msg_type: "accept_offers_reply",
                                msg_value: txid,
                            });
                            var emsg = await super_nostr.alt_encrypt( aggeus_interface.coordinators_privkey, recipient, message );
                            var event = await super_nostr.prepEvent( aggeus_interface.coordinators_privkey, emsg, 4, [ [ "p", recipient ] ] );
                            super_nostr.sendEvent( event, relay );

                            offers_accepted.forEach( ( offer_id, index ) => {
                                var funding_txid = tapscript.Tx.util.getTxid( tx_to_work_with );
                                var funding_vout = tx_to_work_with.vout.length - ( index + 1 );
                                if ( offers[ `${offer_id}_${market_id}` ].odds_per_yes_better ) {
                                    var yes_better = offers[ `${offer_id}_${market_id}` ].yes_better;
                                    var no_better = tapscript.Address.fromScriptPubKey( tx_to_work_with.vin[ offers_accepted.length ].prevout.scriptPubKey, aggeus_interface.mempool_network );
                                    if ( !betters.hasOwnProperty( no_better ) ) betters[ no_better ] = [];
                                    betters[ no_better ].push( `${offer_id}_${market_id}` );
                                } else {
                                    var yes_better = tapscript.Address.fromScriptPubKey( tx_to_work_with.vin[ offers_accepted.length ].prevout.scriptPubKey, aggeus_interface.mempool_network );
                                    var no_better = offers[ `${offer_id}_${market_id}` ].no_better;
                                    if ( !betters.hasOwnProperty( yes_better ) ) betters[ yes_better ] = [];
                                    betters[ yes_better ].push( `${offer_id}_${market_id}` );
                                }
                                if ( offers[ `${offer_id}_${market_id}` ].odds_when_yes_better_entered ) var odds_when_yes_better_entered = offers[ `${offer_id}_${market_id}` ].odds_when_yes_better_entered;
                                else var odds_when_yes_better_entered = offers[ `${offer_id}_${market_id}` ].odds_when_no_better_entered;
                                if ( offers[ `${offer_id}_${market_id}` ].odds_when_no_better_entered ) var odds_when_no_better_entered = offers[ `${offer_id}_${market_id}` ].odds_when_no_better_entered;
                                else var odds_when_no_better_entered = offers[ `${offer_id}_${market_id}` ].odds_when_yes_better_entered;
                                offers[ `${offer_id}_${market_id}` ] = { offer_id, market_id, yes_psbt: null, no_psbt: null, odds_per_yes_better: null, odds_per_no_better: null, yes_better, no_better, odds_when_yes_better_entered, odds_when_no_better_entered, status: "active", funding_outpoint: `${funding_txid}_${funding_vout}` };
                            });
                        }
                    }
                    var connection_id = await super_nostr.newPermanentConnection( aggeus_interface.coordinators_relays[ 0 ], listenFunction, handleFunction );
                    console.log( 'connected!', connection_id );
                    console.log( 'users can talk to me at this pubkey:' );
                    console.log( aggeus_interface.coordinators_pubkey );
                    console.log( 'and this relay:' );
                    console.log( aggeus_interface.coordinators_relays[ 0 ] );
                })();
            }
            var showPage = page => {
                $$( '.top_level_page' ).forEach( page => page.classList.add( "hidden" ) );
                $( `.${page}` ).classList.remove( "hidden" );
            }
            $( '.users_yes_info_btn' ).onclick = () => {
                if ( !$( `.users_yes_info` ).classList.contains( "hidden" ) ) $( `.users_yes_info` ).classList.add( "hidden" );
                else $( `.users_yes_info` ).classList.remove( "hidden" );
            }
            $( '.users_no_info_btn' ).onclick = () => {
                if ( !$( `.users_no_info` ).classList.contains( "hidden" ) ) $( `.users_no_info` ).classList.add( "hidden" );
                else $( `.users_no_info` ).classList.remove( "hidden" );
            }
        </script>
    </body>
</html>
